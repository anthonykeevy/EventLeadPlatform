<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>3</storyId>
    <title>RBAC Middleware & Authorization</title>
    <status>Approved</status>
    <generatedAt>2025-10-16</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/story-1.3.md</sourceStoryPath>
  </metadata>

  <acceptance_criteria>
    <ac id="AC-1.3.1" priority="critical">
      <statement>JWT authentication middleware validates access tokens on protected endpoints</statement>
      <validation>
        <method>Integration Test</method>
        <success_condition>Middleware extracts Bearer token, validates signature and expiry, continues to endpoint if valid; returns 401 if missing/invalid/expired</success_condition>
      </validation>
    </ac>
    <ac id="AC-1.3.2" priority="high">
      <statement>Middleware extracts and validates JWT payload (user_id, email, role, company_id)</statement>
      <validation>
        <method>Unit Test</method>
        <success_condition>JWT decoded successfully; all claims extracted and validated; token type verified as 'access'</success_condition>
      </validation>
    </ac>
    <ac id="AC-1.3.3" priority="high">
      <statement>Current user information injected into request state (request.state.user)</statement>
      <validation>
        <method>Integration Test</method>
        <success_condition>request.state.user contains CurrentUser model with user_id, email, role, company_id; accessible in endpoint handlers</success_condition>
      </validation>
    </ac>
    <ac id="AC-1.3.4" priority="high">
      <statement>Role-based authorization decorator @require_role("role_name") enforces role requirements</statement>
      <validation>
        <method>Integration Test</method>
        <success_condition>Endpoint with @require_role("company_admin") allows company_admin, returns 403 for company_user</success_condition>
      </validation>
    </ac>
    <ac id="AC-1.3.5" priority="high">
      <statement>Company context middleware ensures multi-tenant data isolation</statement>
      <validation>
        <method>Integration Test</method>
        <success_condition>Company_id extracted from JWT, stored in request.state; company filtering enforced on queries</success_condition>
      </validation>
    </ac>
    <ac id="AC-1.3.6" priority="high">
      <statement>Middleware handles missing, invalid, and expired tokens gracefully</statement>
      <validation>
        <method>Integration Test</method>
        <success_condition>Missing token returns 401 with "Missing authorization header"; invalid token returns 401 with "Invalid token"; expired token returns 401 with "Token has expired"</success_condition>
      </validation>
    </ac>
    <ac id="AC-1.3.7" priority="high">
      <statement>Unauthorized access returns 401 (unauthenticated) or 403 (forbidden)</statement>
      <validation>
        <method>Integration Test</method>
        <success_condition>No token or invalid token: 401; valid token but wrong role: 403</success_condition>
      </validation>
    </ac>
    <ac id="AC-1.3.8" priority="medium">
      <statement>Request context updated with user_id and company_id for logging</statement>
      <validation>
        <method>Integration Test</method>
        <success_condition>log.ApiRequest records include UserID and CompanyID from JWT; correlates with authenticated requests</success_condition>
      </validation>
    </ac>
    <ac id="AC-1.3.9" priority="high">
      <statement>Dependency injection get_current_user() provides user in endpoints</statement>
      <validation>
        <method>Unit Test</method>
        <success_condition>Depends(get_current_user) returns CurrentUser model from request.state; raises 401 if not authenticated</success_condition>
      </validation>
    </ac>
    <ac id="AC-1.3.10" priority="medium">
      <statement>All protected endpoint access logged to log.ApiRequest (via Story 0.2)</statement>
      <validation>
        <method>Database Query</method>
        <success_condition>Protected endpoint calls logged with UserID and CompanyID; anonymous requests have NULL UserID</success_condition>
      </validation>
    </ac>
  </acceptance_criteria>

  <dependencies>
    <dependency type="story" status="ready">
      <id>Story 1.2</id>
      <description>Login & JWT - Provides JWT tokens for authentication</description>
    </dependency>
    <dependency type="story" status="completed">
      <id>Story 0.2</id>
      <description>Automated Logging - Provides request context for user logging</description>
    </dependency>
  </dependencies>

  <notes>
    <note type="critical">
      This story MUST be completed BEFORE Stories 1.5, 1.6, 1.7 because those stories require role-based authorization. Story 1.5 (Onboarding) needs protected endpoints. Story 1.6 (Invitations) needs company_admin role enforcement. Do not proceed with protected endpoints until this story is complete.
    </note>
    <note type="architecture">
      The middleware executes in LIFO order (last added runs first). Order matters: RequestLoggingMiddleware should run first (to log all requests), then JWTAuthMiddleware (to authenticate). Register in main.py accordingly.
    </note>
    <note type="security">
      JWT validation is the security foundation. Ensure signature verification is enabled. Use strong JWT secret (32+ characters). Consider implementing token blacklisting for logout functionality in future.
    </note>
    <note type="integration">
      The CurrentUser model from request.state.user is the single source of truth for the authenticated user. All endpoints should use this via Depends(get_current_user) rather than decoding tokens again.
    </note>
  </notes>
</story-context>

